# Full-stack Engineer Written Challenge Keys

## 1. Monitoring and testing

For the tools that I would be using, to start it off, I would go with anything that the team is most comfortable with. I hate to chase the latest cool things and ended up refactoring compatibility stuff and digging out of pitfalls for the new products. If I have to choose one of my preference, I would go with [Grafana](https://grafana.com/) and [JMeter](https://jmeter.apache.org/), the most stable and widely used tools as far as I know for performance testing and log monitoring. With Grafana, it is also really easy to automate alerts through Alert Manager and run Prometheus queries for the logs, providing a pretty mature tooling to the pipeline.

On top of those general tools given the stack for matters lab, to identify performance bottlenecks, we can start looking at [React Dev tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi) & [profiler APIs](https://react.dev/reference/react/Profiler) for component rendering performance probing, [SonarCube](https://www.sonarsource.com/products/sonarqube/) for code smell, [Snyk](https://snyk.io) for npm package security, and so on. For unit and react component testing, I would go with [vitest](https://vitest.dev/) and [react-testing-library](https://testing-library.com/docs/react-testing-library/intro/), two of the state of the art light weight lib for testing those kind of things and mock data with [MSW](https://mswjs.io/). For integration testing I would go with [Cypress](https://www.cypress.io/), not that anything that's significantly better than this. Most of those tests can be ran in a github action fashion to automate it. You can host them either on cypress.io or use headless instances

Given the unique nature of an onchain app for Matters, ETH contract auditing and ipfs stability and security also needs to be taken care of. External auditing for the contract should be performed multiple times and IPFS access controls should be reviewed from time to time on top of running multiple internal ipfs instances for the app instead of relying on public gateways. Fallback blockchain nodes should also be taken into consideration, having running interanl nodes + external providers to crosscheck data between them can also be a meature to ensure data integrity and completeness in case of rollbacks and re-orgs of transactions that involve curated content on Matters.

For the backend GraphQL server that analyze and pins dta to IPFS and listens to events, I would really suggest migrating that off of GraphQL actually. Based on my past experience and with cross-functional teams, this should be gradually move off of the stack. With the new server actions and tRPC stuff, it can be safely decoupled into these components with reduced complexity, less code and better developer experience given that the matters stack is based on nextjs. If we want to secure GraphQL server, we can use API Gateways to manage ACL, add [Typed GraphQL](https://typegraphql.com) for schema validation, rate limiting, input validation, adding JWT, enforcing query depth limits to avoid DDoS attack, etc. To take this a step further, you can have the schema getting and their resolver functions audited periodically as well. To take an extra step, since TypeScript do no guarantee runtime type safety, adding some [io-ts](https://github.com/gcanti/io-ts) magic for codec parsing between API and other services can be worth the investment as well.

## 2. Achitecture & Scalability

Based on a blog [post](https://matters-lab.io/blog/matters-news-renames-domain-to-matters-town) from 2023, I wanna say the current amount of users on Matters is around 500K? given that there are more than 100k creators on the app, my very naive assumption is the ratio of viewer and creator is 4:1. My rule of thumb for scaling is always horizontal scaling over vertical scaling in a start up environment actually. The cost of engineering hours is high in early stage startups tryna scale, and buying more servers is a managable cost comparing to the risks of breaking the platform or causing incidents during migration and refactoring the codebase, let along that refactoring creates no new features, so it really does not fit the objectives of early stage start ups of move fast and break things and to iterate on testing a vision along the way. That being said, to vertically scale this architecture, first is we need to identify the bottleneck, either through manual testing or stats from load/integration testing of the components of the apps.

For the backend component,

- GraphQL server: horizontally scale by adding more server. not much to do here but we can always swap out more performant library or come up with a more light-weight in-house GQL server wrapper to be used so it doesn't end up with a ginormous `node_module` monstrosity.
- Database index + schema + query performance: With Postgres & Elasticsearch (I assume is for storing logs), we can optimize the index and figure out what is the better ways to perform joins for queries. #1 thing on the mind should be eliminate any unnecessary database scan due to lack of indexes.
- Cache optimization: We have redis already, so we can horizontally scale redis or add Kafka to help out request in MQ to offload traffic in Redis and run transform/ETL pipeline for the data/cache. It is hard to say the exact use case for this just based on assumption, but this is the one scenario I can think of that may help scaling this component.

Are the top three things I could've thought about. I assume that the localization + mail services can be ran asynchronously and not in a huge traffic demand as the other ones.

For the frontend component,

- CDNs: Seems like you guys already have one. I guess another thing is running some server-side renders on edge runtime to horizontally scale ssr can be helpful
- Component Modularization + Server Component: Move as much stuff off of client side React and especially leave data fetching over at the server. Server Component actually comes in really handy once gradual adoption starts, and if not, server actions is always a great way to leverage native Next.js server calls to avoid using wrappers or external usually not so performant query handlers
- Client side cache: If there's any state management tasks that goes beyond `useState`, with Apollo cache or other state management tools like Zustand may help alleviate some performance compromises

For the p2p client components, maybe looking at Network Usage and optimizing network communication that reduced latency can help too. Consider running performance tests every once in a while and implement some sort of kubernetes like autoscale mechanism in the cloud just in case, which I assume this is already taken care of given the amount of components in the app.

Whether this goes 10 folds or 100 folds, it's always tyring to make sure computation happens efficiently. For example, using SSG over SSR over ISR over CSR for rendering, optimizing components that may hits bottleneck pretty quickly such as IPFS communication and cache content in Redis/Kafka, or it is multi-thread read/write speed on server side nodejs code or the database. If really necessary which I think it is hard to get there, consider gradually moving some microservice components off to more performant languages, something like the migration [here](https://discord.com/blog/why-discord-is-switching-from-go-to-rust) that Discord has worked on to iterate a more performant solution based on specific use case and their bottleneck.

## 3. Personal Interest

I am excited about the prospect of a decentralized web future, and I think the ideal onchain solution is very close to what I want the future of web to be. I am always a fan of self-governed or soverign media, such as the concepts of [small web](https://benhoyt.com/writings/the-small-web-is-beautiful/) or [web0](https://web0.small-web.org), and I am very excited about the rejuvenation of SSG content like personal blog pages, webrings, indie web builders and moving off of proprietory software. I feel happy about being part of a more accessible web, stuff like web components, 11ty, things powering small but efficient applications that people can use to build software or automation. We all know that pretty much any softwares are just database wrappers, but I feel facebook or twitter (now x) is too much for the generation to take. The misinformation, censorship from less than a handful of people, monopolized monetization model, harvesting attention span for ad times... I don't think this is what I want for me or the future generation of web and how we would live in a digital age. This is more than painful to watch on the side line, and extra painful to be in knowing that you can't escape.

Matters is experimenting a new model of co-living community experience on the internet that I find extremely interesting, and the innovation around monetization with morale is very intriguing as well. To make a change is to be part of an initiatives that resembles my value, that it is important to bring in meaingful work that brings a more egalitarian community which people can socialize and have a good time while it lasts. This is what I find interesting.

I am currently working on a side-hustle for web and tech career consulting, and I built a [tool](https://www.v0.engineer/) to automate a lot of my PDF/resume editing process with LLMs. This is still a prototype but I am exploring technogolies in the AI space to see what's up with the ecosystem and keep myself up-to-date with the current state of tech. I love exploring Programming langagues on the side such as Elixir and I am a big fan for Functional Programming in general. In my past experience I had a great time working with [fp-ts](https://gcanti.github.io/fp-ts/) and [io-ts](https://github.com/gcanti/io-ts), and prior I worked with Scala on some big data visualization stuff.

I think I am excited to build products and make my life easier, and hopefully someone else just like me can benefit from it as well. My most effective way to learn things is by doing, and I will find something like [build you own x](https://github.com/codecrafters-io/build-your-own-x) to get a sense of what I can build with the tools to find inspiration and motivation for doing so. I don't want to make things that people won't use, so I am curious about jumping ahaed to see what is ahead of me. When I start working on things I prefer just go all in into the flow state to let the wave carry me without interruption. This method has been quite effective for me in general.
