# Full-stack Engineer Written Challenge Keys

## 1. Monitoring and testing

For the tools that I would be using, to start it off, I would go with anything that the team is most comfortable with. I hate to chase the latest cool things and ended up refactoring compatibility stuff and digging out of pitfalls for the new products. If I have to choose one of my preference, I would go with [Grafana](https://grafana.com/) and [JMeter](https://jmeter.apache.org/), the most stable and widely used tools as far as I know for performance testing and log monitoring. With Grafana, it is also really easy to automate alerts through Alert Manager and run Prometheus queries for the logs, providing a pretty mature tooling to the pipeline.

On top of those general tools given the stack for matters lab, to identify performance bottlenecks, we can start looking at [React Dev tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi) & [profiler APIs](https://react.dev/reference/react/Profiler) for component rendering performance probing, [SonarCube](https://www.sonarsource.com/products/sonarqube/) for code smell, [Snyk](https://snyk.io) for npm package security, and so on. For unit and react component testing, I would go with [vitest](https://vitest.dev/) and [react-testing-library](https://testing-library.com/docs/react-testing-library/intro/), two of the state of the art light weight lib for testing those kind of things and mock data with [MSW](https://mswjs.io/). For integration testing I would go with [Cypress](https://www.cypress.io/), not that anything that's significantly better than this. Most of those tests can be ran in a github action fashion to automate it. You can host them either on cypress.io or use headless instances

Given the unique nature of an onchain app for Matters, ETH contract auditing and ipfs stability and security also needs to be taken care of. External auditing for the contract should be performed multiple times and IPFS access controls should be reviewed from time to time on top of running multiple internal ipfs instances for the app instead of relying on public gateways. Fallback blockchain nodes should also be taken into consideration, having running interanl nodes + external providers to crosscheck data between them can also be a meature to ensure data integrity and completeness in case of rollbacks and re-orgs of transactions that involve curated content on Matters.

For the backend GraphQL server that analyze and pins dta to IPFS and listens to events, I would really suggest migrating that off of GraphQL actually. Based on my past experience and with cross-functional teams, this should be gradually move off of the stack. With the new server actions and tRPC stuff, it can be safely decoupled into these components with reduced complexity, less code and better developer experience given that the matters stack is based on nextjs. If we want to secure GraphQL server, we can use API Gateways to manage ACL, add [Typed GraphQL](https://typegraphql.com) for schema validation, rate limiting, input validation, adding JWT, enforcing query depth limits to avoid DDoS attack, etc. To take this a step further, you can have the schema getting and their resolver functions audited periodically as well. To take an extra step, since TypeScript do no guarantee runtime type safety, adding some [io-ts](https://github.com/gcanti/io-ts) magic for codec parsing between API and other services can be worth the investment as well.

## 2. Achitecture & Scalability

## 3. Personal Interest
